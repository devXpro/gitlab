# Example GitLab CI/CD Pipeline
# This demonstrates:
# - Building and testing a Node.js application
# - Building and pushing Docker images to Container Registry
# - Publishing npm packages to Package Registry
#
# Runner Configuration:
# This pipeline uses Socket Mounting approach (runner has access to host Docker)
# No need for docker:dind service - jobs use host Docker daemon directly

# Define pipeline stages
stages:
  - build
  - test
  - package
  - deploy

# Global variables
variables:
  # Docker image for Node.js jobs
  NODE_IMAGE: node:20-alpine

  # Container Registry
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  IMAGE_LATEST: $CI_REGISTRY_IMAGE:latest

# ===========================================
# BUILD STAGE
# ===========================================

build-node:
  stage: build
  image: $NODE_IMAGE
  tags:
    - docker
    - linux
    - arm64
  script:
    - echo "Installing dependencies..."
    - npm ci --cache .npm --prefer-offline
    - echo "Building application..."
    - npm run build
  artifacts:
    paths:
      - dist/
      - node_modules/
    expire_in: 1 hour
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .npm/

# ===========================================
# TEST STAGE
# ===========================================

test-unit:
  stage: test
  image: $NODE_IMAGE
  tags:
    - docker
  dependencies:
    - build-node
  script:
    - echo "Running unit tests..."
    - npm run test:unit
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      junit: junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml

test-lint:
  stage: test
  image: $NODE_IMAGE
  tags:
    - docker
  dependencies:
    - build-node
  script:
    - echo "Running linter..."
    - npm run lint

# ===========================================
# PACKAGE STAGE
# ===========================================

# Build and push Docker image
# Uses host Docker daemon via socket mounting (no dind service needed)
docker-build:
  stage: package
  image: docker:latest
  tags:
    - docker
  before_script:
    - echo "Logging into Container Registry..."
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - echo "Building Docker image..."
    - docker build -t $IMAGE_TAG -t $IMAGE_LATEST .
    - echo "Pushing to Container Registry..."
    - docker push $IMAGE_TAG
    - docker push $IMAGE_LATEST
  only:
    - main
    - develop
    - tags

# Publish npm package
npm-publish:
  stage: package
  image: $NODE_IMAGE
  tags:
    - docker
  dependencies:
    - build-node
  before_script:
    - echo "Setting up npm authentication..."
    - echo "//${CI_SERVER_HOST}/api/v4/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=${CI_JOB_TOKEN}" > .npmrc
    - echo "@${CI_PROJECT_ROOT_NAMESPACE}:registry=https://${CI_SERVER_HOST}/api/v4/projects/${CI_PROJECT_ID}/packages/npm/" >> .npmrc
  script:
    - echo "Publishing npm package..."
    - npm publish
  only:
    - tags
  except:
    - branches

# ===========================================
# DEPLOY STAGE
# ===========================================

deploy-staging:
  stage: deploy
  image: alpine:latest
  tags:
    - docker
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to staging environment..."
    - echo "Image: $IMAGE_TAG"
    # Add your deployment commands here
    # Example: kubectl set image deployment/myapp myapp=$IMAGE_TAG
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - develop

deploy-production:
  stage: deploy
  image: alpine:latest
  tags:
    - docker
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to production environment..."
    - echo "Image: $IMAGE_TAG"
    # Add your deployment commands here
  environment:
    name: production
    url: https://example.com
  when: manual
  only:
    - main
    - tags

